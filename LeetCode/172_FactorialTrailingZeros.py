class Solution:
    def trailingZeroes(self, n: int) -> int: 
        res = 0 
        while n > 0: 
            n //= 5 
            res += n 
        return res 

'''
    第一反应是暴力的解法，求出对应的阶乘值，然后对10进行整除，直到不能整除为止，得到的就是末尾0的数量
    该方法时间复杂度略小于O(n²)，实际中不可能使用

    对阶乘的各项进行分析，阶乘值中末尾的0都是乘以10得到的，且只会增多不会减少，而10又只能分解为2*5
    因此只需要找到阶乘式中可以分解为含有因子2、5的项。分析可得，含有因子2的项每两个项中出现一个，含有
    因子5的项每五个项出现一个，因此含因子2的项的数量一定大于含因子5的项的数量，只需要求出含有因子5的项
    的个数即可

    n // 5 可以得到含有因子5的项的数量，同时注意到，每隔25个项，该项会含有两个因子5，同理每隔125个项，
    该项会含有三个因子5，以此可以类推到后续5的任意幂。所以令每次循环n = n // 5，累加上这些额外的因子5(
    因子2同理，所以最后分解得到的因子2数量仍远大于因子5)，最后得到所有因子5的数量，即为阶乘值末尾0的数量
'''